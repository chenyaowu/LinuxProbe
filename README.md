# LinuxProbe
# 第2章-新手必须掌握的 Linux 命令 



## 常用系统工作命令



### 1.echo命令

- echo 命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。

  ```bash
  [root@linuxprobe ~]# echo Linuxprobe.Com
  Linuxprobe.Com
  [root@linuxprobe ~]# echo $SHELL
  /bin/bash
  ```

### 2.date命令

- date 命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。

  | 参数 | 作用           |
  | ---- | -------------- |
  | %t   | 跳格[Tab键]    |
  | %H   | 小时(00~23)    |
  | %I   | 小时(00~12)    |
  | %M   | 分钟(00~59)    |
  | %s   | 秒(00~59)      |
  | %j   | 今年中的第几天 |

  ```ba
  按照默认格式查看当前系统时间
  [root@linuxprobe ~]# date
  Mon Aug 24 16:11:23 CST 2017 
  按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间
  [root@linuxprobe ~]# date "+%Y-%m-%d %H:%M:%S"
  2017-08-24 16:29:12 
  设置时间
  [root@linuxprobe ~]# date -s "20170901 8:30:00"
  Fri Sep 1 08:30:00 CST 2017 
  查看今天是当年中的第几天
  [root@linuxprobe ~]# date "+%j" 
  244
  ```

### 3.reboot命令

- reboot 命令用于重启系统

### 4.poweroff 命令

- poweroff 命令用于关闭系统

### 5.wget 命令

- wget 命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址”。

  | 参数 | 作用                               |
  | ---- | ---------------------------------- |
  | -b   | 后台下载模式                       |
  | -P   | 下载到指定目录                     |
  | -t   | 最大尝试次数                       |
  | -c   | 断点续传                           |
  | -p   | 下载页面所有资源，包括图片、视频等 |
  | -r   | 递归下载                           |

  

### 6.ps命令

- ps 命令用于查看系统中的进程状态，格式为“ps [参数]”。

  | 参数 | 作用                               |
  | ---- | ---------------------------------- |
  | -a   | 显示所有进程（包括其他用户的进程） |
  | -u   | 用户以及其他详细信息               |
  | -x   | 显示没有控制终端的进程             |

- 5种常见的进程状态

  - R（运行）：进程正在运行或在运行队列中等待。 
  -  S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该 状态。 
  - D（不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 
  - Z（僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数 后将进程释放。 
  - T（停止）：进程收到停止信号后停止运行。

- ps输出信息

  | USER         | PID      | %CPU         | %MEM       | VSZ                  | RSS                    | TTY        | STAT     | START        | TIME              | COMMAND          |
  | ------------ | -------- | ------------ | ---------- | -------------------- | ---------------------- | ---------- | -------- | ------------ | ----------------- | ---------------- |
  | 进程的所有者 | 进程ID号 | 运算器占用率 | 内存占用率 | 虚拟内存使用量（KB） | 占用的固定内存量（KB） | 所在的终端 | 进程状态 | 被启动的时间 | 实际使用CPU的时间 | 命令名称与参数   |
  | root         | 1        | 0.0          | 0.14       | 53684                | 7628                   | ?          | Ss       | 07:00        | 0:22              | /usr/lib/systemd |

### 7.top 命令

- top 命令用于动态地监视进程活动与系统负载等信息
  - 第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、5 分钟、15 分钟内的平均值，数值越小意味着负载越低）。 
  - 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程 数。 
  - 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源 百分比、空闲的资源百分比等。(数据均为 CPU 数据并以百分比格式显示，例如“97.1 id”意味着有 97.1% 的 CPU 处理器资源处于空闲。)
  - 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 
  - 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。

### 8.pidof 命令 

- pidof 命令用于查询某个指定服务进程的 PID 值，格式为“pidof [参数] [服务名称]”。

  ```ba
  [root@linuxprobe ~]# pidof sshd
  2156 
  ```

### 9.kill 命令

- kill 命令用于终止某个指定 PID 的服务进程，格式为“kill [参数] [进程 PID]”。

### 10.killall 命令

 - killall 命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进 程名称]”。



 ## 系统状态检测命令 

### 1.ifconfig 命令

- ifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。

### 2.uname 命令 

- uname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。

### 3.uptime 命令

- uptime 用于查看系统的负载信息，格式为 uptime

### 4.free 命令

- free 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。

  |                  | 内存总量 | 已用量 | 可用量 | 进程共享的内存量 | 磁盘缓存的内存量 | 缓存的内存量 |
  | ---------------- | -------- | ------ | ------ | ---------------- | ---------------- | ------------ |
  |                  | total    | used   | free   | shared           | buffers          | cached       |
  | Mem              | 1.8GB    | 1.3GB  | 542MB  | 9.8MB            | 1.6MB            | 413MB        |
  | -/+buffers/cache |          | 869MB  | 957MB  |                  |                  |              |
  | Swap             | 2.0GB    | 0      | 2.0GB  |                  |                  |              |

### 5.who 命令

- who 用于查看当前登入主机的用户终端信息，格式为“who [参数]”。

  | 登录的用户名 | 终端设备 | 登录到系统的时间     |
  | ------------ | -------- | -------------------- |
  | root         | :0       | 2017-08-24 17:52(:0) |
  | root         | pts/0    | 2017-08-24 17:52(:0) |

### 6.last 命令

- last 命令用于查看所有系统的登录记录，格式为“last [参数]”。

### 7.history 命令 

- history 命令用于显示历史执行过的命令，格式为“history [-c]”。

### 8.sosreport 命令 

- sosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。

## 工作目录切换命令 

### 1.pwd 命令

- pwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。

### 2.cd 命令

- cd 命令用于切换工作路径，格式为“cd [目录名称]”。

### 3.ls 命令

- ls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。
  - “-a”参数看 到全部文件（包括隐藏文件）。
  - “-l”参数可以查看文件的属性、大小等详细信息。
  - “-d”参数查看目录属性信息

## 文本文件编辑命令 

### 1.cat 命令

- cat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。
  - 显示行号加-n参数

### 2.more 命令

- more 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。
  - 使用空格键或回 车键向下翻页

### 3.head 命令

- head 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。

### 4.tail 命令

- tail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。

  ```bash
  查看最后20行
  [root@linuxprobe ~]# tail -n 20 /var/log/messages 
  ```

### 5. tr 命令

- tr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。

### 6.wc 命令

- wc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。

  | 参数 | 作用         |
  | ---- | ------------ |
  | -l   | 只显示行数   |
  | -w   | 只显示单词数 |
  | -c   | 只显示字节数 |

### 7.stat 命令 

- stat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。

### 8.cut 命令

- cut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。

### 9.diff 命令

- diff 命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。

## 文件目录管理命令

### 1.touch 命令

- touch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。

  | 参数 | 作用                    |
  | ---- | ----------------------- |
  | -a   | 仅修改“读取时间”(atime) |
  | -m   | 仅修改“修改时间”(mtime) |
  | -d   | 同时修改atime与mtime    |

### 2.mkdir 命令

- mkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。

  ```bash
  使用-p递归创建层级关系目录
  [root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e 
  ```

### 3.cp 命令 

- cp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。

  - 如果目标文件是目录，则会把源文件复制到该目录中；

  - 如果目标文件也是普通文件，则会询问是否要覆盖它；

  - 如果目标文件不存在，则执行正常的复制操作。

    | 参数 | 作用                                         |
    | ---- | -------------------------------------------- |
    | -p   | 保留原始文件的属性                           |
    | -d   | 若对象为“链接文件”，则保留该“链接文件”的属性 |
    | -r   | 递归持续复制（用于目录）                     |
    | -i   | 若目标文件存在则询问是否覆盖                 |
    | -a   | 相当于-pdr（p、d、r 为上述参数）             |

### 4.mv 命令

- mv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。

### 5.rm 命令

- rm 命令用于删除文件或目录，格式为“rm [选项] 文件”。

### 6. dd 命令

- dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。

### 7.file 命令

- file 命令用于查看文件的类型，格式为“file 文件名”。

## 打包压缩与搜索命令

### 1.tar 命令

- tar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。

  | 参数 | 作用                   |
  | ---- | ---------------------- |
  | -c   | 创建压缩文件           |
  | -x   | 解开压缩文件           |
  | -t   | 查看压缩包内有哪些文件 |
  | -z   | 用 Gzip 压缩或解压     |
  | -j   | 用 bzip2 压缩或解压    |
  | -v   | 显示压缩或解压的过程   |
  | -f   | 目标文件名             |
  | -p   | 保留原始的权限与属性   |
  | -P   | 使用绝对路径来压缩     |
  | -C   | 指定解压到的目录       |

### 2.grep 命令 

- grep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。

  | 参数 | 作用                                             |
  | ---- | ------------------------------------------------ |
  | -b   | 将可执行文件（binary）当作文本文件（text）来搜索 |
  | -c   | 仅显示找到的行数                                 |
  | -i   | 忽略大小写                                       |
  | -n   | 显示行号                                         |
  | -v   | 反向选择—仅列出没有“关键词”的行                  |

### 3.find 命令

- find 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。

  | 参数               | 作用                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | -name              | 匹配名称                                                     |
  | -perm              | 匹配权限（mode 为完全匹配，-mode 为包含即可                  |
  | -user              | 匹配所有者                                                   |
  | -group             | 匹配所有组                                                   |
  | -mtime -n +n       | 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前）         |
  | -atime -n +n       | 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前）         |
  | -ctime -n +n       | 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前）     |
  | -nouser            | 匹配无所有者的文件                                           |
  | -nogroup           | 匹配无所有组的文件                                           |
  | -newer f1 !f2      | 匹配比文件 f1 新但比 f2 旧的文件                             |
  | --type b/d/c/p/l/f | 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、 链接文件、文本文件） |
  | -size              | 匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件） |
  | -prune             | 忽略某个目录                                                 |
  | -exec …… {}\;      | 后面可跟用于进一步处理搜索结果的命令                         |

  

# 第3章管道符、重定向与环境变量

## 输入输出重定向

- 输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到 屏幕的数据信息写入到指定文件中

- 标准输入重定向（STDIN，文件描述符为 0）：默认从键盘输入，也可从其他文件或命令中输入

- 标准输出重定向（STDOUT，文件描述符为 1）：默认输出到屏幕。

- 错误输出重定向（STDERR，文件描述符为 2）：默认输出到屏幕。

- 输入重定向中用到的符号及其作用

  | 符号                   | 作用                                            |
  | ---------------------- | ----------------------------------------------- |
  | 命令 < 文件            | 将文件作为命令的标准输入                        |
  | 命令 << 分界符         | 从标准输入中读入，直到遇见分界符才停止          |
  | 命令 < 文件 1 > 文件 2 | 将文件 1 作为命令的标准输入并将标准输出到文件 2 |

  

- 输出重定向中用到的符号及其作用

  - 对于重定向中的标准输出模式，可以省略文件描述符 1 不写，而错误输出模式的文件描述符 2 是必须要写的。

  | 符号                               | 作用                                                         |
  | ---------------------------------- | ------------------------------------------------------------ |
  | 命令 > 文件                        | 将标准输出重定向到一个文件中（清空原有文件的数据）           |
  | 命令 2> 文件                       | 将错误输出重定向到一个文件中（清空原有文件的数据）           |
  | 命令 >> 文件                       | 将标准输出重定向到一个文件中（追加到原有内容的后面）         |
  | 命令 2>> 文件                      | 将错误输出重定向到一个文件中（追加到原有内容的后面）         |
  | 命令 >> 文件 2>&1 或 命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的 后面） |

## 管道命令符

- 格式 命令 A | 命令 B |

- 把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输 入

## 命令行的通配符 

- 星号（*）代 表匹配零个或多个字符
- 问号（?）代表匹配单个字符
- 中括号内加上数字[0-9]代表匹配 0～9 之间的单个数字的字符
- 中括号内加上字母[abc]则是代表匹配 a、b、c 三个字符中的任意 一个字符。

## 常用的转义字符 

- 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。
- 单引号（''）：转义其中所有的变量为单纯的字符串。
- 双引号（""）：保留其中的变量属性，不进行转义处理。
- 反引号（``）：把其中的命令执行后返回结果。

## 重要的环境变量 

- 在用 户执行了一条命令之后，分别执行4个步骤

  - 第1步：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话 则直接执行。
  - 第2步：Linux 系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令 名称来替换原本的命令名称。可以用 alias 命令来创建一个属于自己的命令别名，格式为 “alias 别名=命令”。若要取消一个命令别名，则是用 unalias 命令，格式为“unalias 别名”。 
  - 第3步：Bash 解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部 的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤 4 继 续处理。可以使用“type 命令名称”来判断用户输入的命令是内部命令还是外部命令。
  - 第4步：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作 PATH，可 以简单地把它理解成是“解释器的小助手”，作用是告诉 Bash 解释器待执行的命令可能存放 的位置，然后 Bash 解释器就会乖乖地在这些位置中逐个查找。PATH 是由多个路径值组成的 变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到 Bash 解释器对 Linux 命令的查找。

- 为什么不能将当前目录（.）添加到 PATH 中呢? 

  - 尽管可以将当前目录（.）添加到 PATH 变量中，从而在某些情况下可以让用户免去输入命令 所在路径的麻烦。但是，如果黑客在比较常用的公共目录/tmp 中存放了一个与 ls 或 cd 命令同 名的木马文件，而用户又恰巧在公共目录中执行了这些命令，那么就极有可能中招了。

- Linux 系统中最重要的 10 个环境变量

  | 变量名称     | 作用                             |
  | ------------ | -------------------------------- |
  | HOME         | 用户的主目录（即家目录）         |
  | SHELL        | 用户在使用的 Shell 解释器名称    |
  | HISTSIZE     | 输出的历史命令记录条数           |
  | HISTFILESIZE | 保存的历史命令记录条数           |
  | MAIL         | 邮件保存路径                     |
  | LANG         | 系统语言、语系名称               |
  | RANDOM       | 生成一个随机数字                 |
  | PS1          | Bash 解释器的提示符              |
  | PATH         | 定义解释器搜索用户执行命令的路径 |
  | EDITOR       | 用户默认的文本编辑器             |




# 第 4 章Vim 编辑器与 Shell 命令脚本 

## Vim 文本编辑器

- 三种模式

  - 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。
  - 输入模式：正常的文本录入。
  - 末行模式：保存或退出文档，以及设置编辑环境。

- Vim 中常用的命令

  | 命令 | 作用                                               |
  | ---- | -------------------------------------------------- |
  | dd   | 删除（剪切）光标所在整行                           |
  | 5dd  | 删除（剪切）从光标处开始的 5 行                    |
  | yy   | 复制光标所在整行                                   |
  | 5yy  | 复制从光标处开始的 5 行                            |
  | n    | 显示搜索命令定位到的下一个字符串                   |
  | N    | 显示搜索命令定位到的上一个字符串                   |
  | u    | 撤销上一步的操作                                   |
  | p    | 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 |

- 末行模式中可用的命令

  | 命令          | 作用                                    |
  | ------------- | --------------------------------------- |
  | :w            | 保存                                    |
  | :q            | 退出                                    |
  | :q!           | 强制退出（放弃对文档的修改内容）        |
  | :wq!          | 强制保存退出                            |
  | :set nu       | 显示行号                                |
  | :set nonu     | 不显示行号                              |
  | :命令         | 执行该命令                              |
  | :整数         | 跳转到该行                              |
  | :s/one/two    | 将当前光标所在行的第一个 one 替换成 two |
  | :s/one/two/g  | 将当前光标所在行的所有 one 替换成 two   |
  | :%s/one/two/g | 将全文中的所有 one 替换成 two           |
  | ?字符串       | 在文本中从下至上搜索该字符串            |
  | /字符串       | 在文本中从上至下搜索该字符串            |

  

## 编写 Shell 脚本

- Shell 脚本命令的工作方式有两种：交互式和批处理

  - 交互式（Interactive）：用户每输入一条命令就立即执行。
  - 批处理（Batch）：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本 中诸多的命令。

- 编写简单的脚本 

  ```bash
  [root@linuxprobe ~]# vim example.sh
  #!/bin/bash
  #For Example BY linuxprobe.com
  pwd
  ls -al 
  --------------------------------------------
  [root@linuxprobe ~]# bash example.sh
  /root/Desktop
  total 8
  drwxr-xr-x. 2 root root 23 Jul 23 17:31 .
  dr-xr-x---. 14 root root 4096 Jul 23 17:31 ..
  -rwxr--r--. 1 root root 55 Jul 23 17:31 example.sh 
  ```

  - Shell 脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh 后缀加上，以表示是一个脚本文件。
  - 在上面的这个 example.sh 脚本中实际上出现了三种不同的元素：
    - 第一行的 脚本声明（#!）用来告诉系统使用哪种 Shell 解释器来执行该脚本；
    - 第二行的注释信息（#）是对 脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该 脚本的作用或一些警告信息；
    - 第三、四行的可执行语句也就是我们平时执行的 Linux 命令了

- 接收用户的参数

  - 如\$0 对应的是当前 Shell 脚本程序的名称
  - \$#对应的是总共 有几个参数，
  - \$*对应的是所有位置的参数值
  - \$?对应的是显示上一次命令的执行返回值
  -  \$1、\$2、\$3……则分别对应着第 N 个位置的参数值
  
  ```bash
  [root@linuxprobe ~]# vim example.sh
  #!/bin/bash
  echo "当前脚本名称为$0"
  echo "总共有$#个参数，分别是$*。"
  echo "第 1 个参数为$1，第 5 个为$5。"
  -------------------------------------------------------
  [root@linuxprobe ~]# sh example.sh one two three four five six
  当前脚本名称为 example.sh
  总共有 6 个参数，分别是 one two three four five six。
  第 1 个参数为 one，第 5 个为 five。
  ```
  
- 判断用户的参数

  - 测试语句格式（两边有空格）： [ 条件语句 ]

    | 运算符 | 作用                       |
    | ------ | -------------------------- |
    | -d     | 测试文件是否为目录类型     |
    | -e     | 测试文件是否存在           |
    | -f     | 判断是否为一般文件         |
    | -r     | 测试当前用户是否有权限读取 |
    | -w     | 测试当前用户是否有权限写入 |
    | -x     | 测试当前用户是否有权限执行 |

    ```bash
    [root@linuxprobe ~]# [ -d /etc/fstab ]
    [root@linuxprobe ~]# echo $?
    1 
    ```

    

  - 逻辑“与”的运算符号是&&，逻辑“与”的运算符号是||，逻辑语句是“非”运算符号是！

    ```bash
    [root@linuxprobe ~]# [ ! $USER = root ] && echo "user" || echo "root"
    root 
    ```

    

    - 可用的整数比较运算符

      | 运算符 | 作用           |
      | ------ | -------------- |
      | -eq    | 是否等于       |
      | -ne    | 是否不等于     |
      | -gt    | 是否大于       |
      | -lt    | 是否小于       |
      | -le    | 是否等于或小于 |
      | -ge    | 是否大于或等于 |

    ```bash
    [root@linuxprobe ~]# [ 10 -gt 10 ]
    [root@linuxprobe ~]# echo $?
    1
    [root@linuxprobe ~]# [ 10 -eq 10 ]
    [root@linuxprobe ~]# echo $?
    0
    ```

    - 常见的字符串比较运算符

      | 运算符 | 作用                   |
      | ------ | ---------------------- |
      | =      | 比较字符串内容是否相同 |
      | !=     | 比较字符串内容是否不同 |
      | -z     | 判断字符串内容是否为空 |

      ```bash
      [root@linuxprobe ~]# [ -z $String]
      [root@linuxprobe ~]# echo $?
      0 
      ```

##  流程控制语句 

  - if 条件测试语句

      - if 条件语句的单分支结构由 if、then、fi 关键词组成，而且只在条件成立后才执行预设的 命令
      - if 条件语句的双分支结构由 if、then、else、fi 关键词组成，它进行一次条件匹配判断， 如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令
      - if 条件语句的多分支结构由 if、then、else、elif、fi 关键词组成，它进行多次条件匹配判 断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令

- for 条件循环语句 

  ```bash
  for 变量名 in 取值列表
  do
  	命令序列
  done
  ```

- while 条件循环语句 

  ```bash
  while 条件测试操作
  do
  	命令序列
  done
  ```

- case 条件测试语句 

  ```bash
  case 变量值 in
  模式1)
  	命令序列2
  	;;
  模式2)
  	命令序列2
  	;;
  	......
  *)
  	默认命令序列
  esac
  ```

  

  ### 计划任务服务程序 

- crond 服务
  
  - 分、时、日、月、星期 命令

| 字段 | 说明                                           |
| ---- | ---------------------------------------------- |
| 分   | 取值为 0～59 的整数                            |
| 时   | 取值为 0～23 的任意整数                        |
| 日   | 取值为 1～31 的任意整数                        |
| 月   | 取值为 1～12 的任意整数                        |
| 星期 | 取值为 0～7 的任意整数，其中 0 与 7 均为星期日 |
| 命令 | 要执行的命令或程序脚本                         |



# 第 5 章用户身份与文件权限 

## 用户身份与能力

- 管理员 UID 为 0：系统的管理员用户。
- 系统用户 UID 为 1～999： Linux 系统为了避免因某个服务程序出现漏洞而被黑客提 权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏 范围。
- 普通用户 UID 从 1000 开始：是由管理员创建的用于日常工作的用户。



- UID 是不能冲突的，而且管理员创建的普通用户的 UID 默认是从 1000 开始的（即使前面有闲置的号码）。
- Linux 系统中还引入了用户组的概念。通过使用用 户组号码（GID，Group IDentification），我们可以把多个用户加入到同一个组中，从而方 便为组中的用户统一规划权限或指定任务。
- 在 Linux 系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且 这个基本用户组只有该用户一个人。如果该用户以后被归纳入其他用户组，则这个其他用户 组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满 足日常的工作需要。

## useradd 命令 

- useradd 命令用于创建新的用户，格式为“useradd [选项] 用户名”。

- 可以使用 useradd 命令创建用户账户。使用该命令创建用户账户时，默认的用户家目录会 被存放在/home 目录中，默认的 Shell 解释器为/bin/bash，而且默认会创建一个与该用户同名 的基本用户组

  | 参数 | 作用                                     |
  | ---- | ---------------------------------------- |
  | -d   | 指定用户的家目录（默认为/home/username） |
  | -e   | 账户的到期时间，格式为 YYYY-MM-DD.       |
  | -u   | 指定该用户的默认 UID                     |
  | -g   | 指定一个初始的用户基本组（必须已存在）   |
  | -G   | 指定一个或多个扩展用户组                 |
  | -N   | 不创建与用户同名的基本用户组             |
  | -s   | 指定该用户的默认 Shell 解释器            |

  

## groupadd 命令

- groupadd 命令用于创建用户组，格式为“groupadd [选项] 群组名”。

- 为了能够更加高效地指派系统中各个用户的权限，在工作中常常会把几个用户加入到同 一个组里面，这样便可以针对一类用户统一安排权限

## usermod 命令

- usermod 命令用于修改用户的属性，格式为“usermod [选项] 用户名”。
  | 参数  | 作用                                                         |
  | ----- | ------------------------------------------------------------ |
  | -c    | 填写用户账户的备注信息                                       |
  | -d -m | 参数-m 与参数-d 连用，可重新指定用户的家目录并自动把旧的数据转移过去 |
  | -e    | 账户的到期时间，格式为 YYYY-MM-DD                            |
  | -g    | 变更所属用户组                                               |
  | -G    | 变更扩展用户组                                               |
  | -L    | 锁定用户禁止其登录系统                                       |
  | -U    | 解锁用户，允许其登录系统                                     |
  | -s    | 变更默认终端                                                 |
  | -u    | 修改用户的 UID                                               |
  

## passwd 命令 

- passwd 命令用于修改用户密码、过期时间、认证信息等，格式为“passwd [选项] [用户名]”。

- 普通用户只能使用 passwd 命令修改自身的系统密码，而 root 管理员则有权限修改其他所 有人的密码。

- root 管理员在 Linux 系统中修改自己或他人的密码时不需要验证旧密 码。

  | 参数    | 作用                                                   |
  | ------- | ------------------------------------------------------ |
  | -l      | 锁定用户，禁止其登录                                   |
  | -u      | 解除锁定，允许用户登录                                 |
  | --stdin | 允许通过标准输入修改用户密码，如echo "NewPassWord"     |
  | -d      | 使该用户可用空密码登录系统                             |
  | -e      | 强制用户在下次登录时修改密码                           |
  | -S      | 显示用户的密码是否被锁定，以及密码所采用的加密算法名称 |

## userdel 命令 

- userdel 命令用于删除用户，格式为“userdel [选项] 用户名”。

  | 参数 | 作用                     |
  | ---- | ------------------------ |
  | -f   | 强制删除用户             |
  | -r   | 同时删除用户及用户家目录 |




## 文件权限与归属 

### 文件类型常见的字符

- -：普通文件。
- d：目录文件。
- l：链接文件。
- b：块设备文件。 
- c：字符设备文件。 
- p：管道文件。

### 文件权限的字符与数字表示

| 权限分配 | 文件- | 所有- | 者 | 文件- | 所属- | 组 | 其他- | - | 用户 |
| -------- | ---------- | ---- | ---- | ---------- | ---- | ---- | -------- | ---- | ---- |
| 权限项 | 读         | 写   | 执行 |   读         | 写   | 执行 |         读         | 写   | 执行 |
| 字符表示 | r | w | x | r | w | x | r | w | x |
| 数字表示 | 4 | 2 | 1 | 4 | 2 | 1 | 4 | 2 | 1 |

```bash
[root@linuxprobe ~]# ls -l initial-setup-ks.cfg 
-rw-r--r--. 1 root root 1083 Aug 31 11:41 initial-setup-ks.cfg
-：文件类型（普通文件）
rw-r--r--：访问权限（所有者权限为可读可写（rw-），所属组权限为可读（r--），其他人也只有可读权限（r--），）
root：属主
root：属组
1083：文件大小
Aug 31 11:41：修改时间
initial-setup-ks.cfg：文件名称

```

## 文件的特殊权限 

### SUID 

- SUID 是一种对二进制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属 主的权限（仅对拥有执行权限的二进制程序有效）。

### SGID 

- SGID 主要实现如下两种功能：
  - 让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）；
  - 在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。

### chmod 命令

- chmod 命令是一个非常实用的命令，能够用来设置文件或目录的权限，格式为“chmod [参 数] 权限 文件或目录名称”

```ba
[root@linuxprobe ~]# ls -al test
-rw-rw-r--. 1 linuxprobe root 15 Feb 11 11:50 test
[root@linuxprobe ~]# chmod 760 test
[root@linuxprobe ~]# ls -l test
-rwxrw----. 1 linuxprobe root 15 Feb 11 11:50 test
```

### chown 命令

- 设置文件或目录的所有者和所属组，其格式为“chown [参数] 所有者:所属组 文件或目录名称”

  ```bash
  [root@linuxprobe ~]# ls -l test
  -rwxrw----. 1 linuxprobe root 15 Feb 11 11:50 test
  [root@linuxprobe ~]# chown root:bin test
  [root@linuxprobe ~]# ls -l test
  -rwxrw----. 1 root bin 15 Feb 11 11:50 test 
  ```

  

### SBIT

- SBIT 特殊权限位可确保用户只能删除自己的文件，而 不能删除其他用户的文件

- chmod  o+t 文件或目录名称



## 文件的隐藏属性 

### chattr 命令 

- chattr 命令用于设置文件的隐藏权限，格式为“chattr [参数] 文件”

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而 不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用 0 填充原文件所在硬盘区域）    |
| A    | 不再修改这个文件或目录的最后访问时间（atim                   |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用 dump 命令备份时忽略本文件/目录                          |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |



### lsattr 命令 

- lsattr 命令用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”



## 文件访问控制列表 

### setfacl 命令

- setfacl 命令用于管理文件的 ACL 规则，格式为“setfacl [参数] 文件名称”

- 针对目录 文件需要使用-R 递归参数；针对普通文件则使用-m 参数；如果想要删除某个文件的 ACL， 则可以使用-b 参数

### getfacl 命令 

- getfacl 命令用于显示文件上设置的 ACL 信息，格式为“getfacl 文件名称”。



## su 命令与 sudo 服务 

| 参数               | 作用                                                     |
| ------------------ | -------------------------------------------------------- |
| -h                 | 列出帮助信息                                             |
| -l                 | 列出当前用户可执行的命令                                 |
| -u 用户名或 UID 值 | 以指定的用户身份执行命令                                 |
| -l                 | 清空密码的有效时间，下次执行 sudo 时需要再次进行密码验证 |
| -b                 | 在后台执行指定的命令                                     |
| -p                 | 更改询问密码的提示语                                     |

- sudo 命令具有如下功能：
  - 限制用户执行指定的命令
  - 记录用户执行的每一条命令
  - 配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数
  - 验证密码的后 5 分钟内（默认值）无须再让用户再次验证密码

- 如果担心直接修改配置文件会出现问题，则可以使用 sudo 命令提供的 visudo 命令 来配置用户权限。这条命令在配置用户权限时将禁止多个用户同时修改 sudoers 配置文件，还 可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错
- 只有 root 管理员才可以使用 visudo 命令编辑 sudo 服务的配置文件。



# 第 6 章存储结构与磁盘划分

## 一切从“/”开始 

- 最常见的目录以及所对应的 存放内容

  | 目录名称    | 应放置文件的内容                                            |
  | ----------- | ----------------------------------------------------------- |
  | /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等               |
  | /dev        | 以文件形式存放任何设备与接口                                |
  | /etc        | 配置文件                                                    |
  | /home       | 用户家目录                                                  |
  | /bin        | 存放单用户模式下还可以操作的命令                            |
  | /lib        | 开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数 |
  | /sbin       | 开机过程中需要的命令                                        |
  | /media      | 用于挂载设备文件的目录                                      |
  | /opt        | 放置第三方的软件                                            |
  | /root       | 系统管理员的家目录                                          |
  | /srv        | 一些网络服务的数据文件目录                                  |
  | /tmp        | 任何人均可使用的“共享”临时目录                              |
  | /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等      |
  | /usr/local  | 用户自行安装的软件                                          |
  | /usr/sbin   | Linux 系统开机时不会使用到的软件/命令/脚本                  |
  | /usr/share  | 帮助与说明文件，也可放置共享文件                            |
  | /var        | 主要存放经常变化的文件，如日志                              |
  | /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里        |

- 绝对路径（absolute path）
- 相对路径（relative path）

## 物理设备的命名规则 

- 常见的硬件设备及其文件名称

  | 硬件设备       | 文件名称            |
  | -------------- | ------------------- |
  | IDE 设备       | /dev/hd[a-d]        |
  | SCSI/SATA/U 盘 | /dev/sd[a-p]        |
  | 软驱           | /dev/fd[0-1]        |
  | 打印机         | /dev/lp[0-15]       |
  | 光驱           | /dev/cdrom          |
  | 鼠标           | /dev/mouse          |
  | 磁带机         | /dev/st0 或/dev/ht0 |

- 由于现在的 IDE 设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。 而一台主机上可以有多块硬盘，因此系统采用 a～p 来代表 16 块不同的硬盘（默认从 a 开始 分配），而且硬盘的分区编号也很有讲究：

  - 主分区或扩展分区的编号从 1 开始，到 4 结束；
  - 逻辑分区从编号 5 开始。

## 文件系统与数据资料 

- Linux 系统支持数十种的文件系统，而最常见的文件系统：
  - Ext3：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并 能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也 会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入 动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分， 然后尝试进行修复
  - Ext4：Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容 量高达 1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4 文件系 统能够批量分配 block 块，从而极大地提高了读写效率。
  - XFS：是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的 优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的 日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB， 这几乎满足了所有需求。

## 挂载硬件设备

 ### mount 命令 

- mount 命令用于挂载文件系统，格式为“mount 文件系统 挂载目录”。

  | 参数 | 作用                                  |
  | ---- | ------------------------------------- |
  | -a   | 挂载所有在/etc/fstab 中定义的文件系统 |
  | -t   | 指定文件系统的类型                    |

  把设备/dev/sdb2 挂载到/backup 目录（临时，重启失效）

  ```bash
  [root@linuxprobe ~]# mount /dev/sdb2 /backup 
  ```

  想让硬件设备和目录永久地进行自动关联，必须把挂载信息按照指定的填写格式 “设备文件 挂载目录 格式类型 权限选项 自检 优先级”（各字段的意义见表 6-4）写入到 /etc/fstab 文件中。

  | 字段     | 意义                                                         |
  | -------- | ------------------------------------------------------------ |
  | 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） |
  | 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
  | 格式类型 | 指定文件系统的格式，比如 Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
  | 权限选项 | 若设置为 defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async |
  | 自检     | 若为 1 则开机后进行磁盘自检，为 0 则不自检                   |
  | 优先级   | 若“自检”字段为 1，则可对多块硬盘进行自检优先级设置           |

  ```bash
  [root@linuxprobe ~]# vim /etc/fstab
  #
  # /etc/fstab
  # Created by anaconda on Wed May 4 19:26:23 2017
  #
  # Accessible filesystems, by reference, are maintained under '/dev/disk'
  # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
  #
  ......
  .....
  ....
  /dev/sdb2 /backup ext4 defaults 0 0
  ```

### umount 命令

- umount 命令用于撤销已经挂载的设备文件，格式为“umount [挂载点/设备文件]”

  ```bash
  [root@linuxprobe ~]# umount /dev/sdb2 
  ```

### 添加硬盘设备

### fdisk 命令

- fdisk 命令用于管理磁盘 分区，格式为“fdisk [磁盘名称]”

  | 参数 | 作用                   |
  | ---- | ---------------------- |
  | m    | 查看全部可用的参数     |
  | n    | 添加新的分区           |
  | d    | 删除某个分区信息       |
  | l    | 列出所有可用的分区类型 |
  | t    | 改变某个分区的类型     |
  | p    | 查看分区信息           |
  | w    | 保存并退出             |
  | q    | 不保存直接退出         |

### du 命令

- 查看文件数据占用量的 du 命令，其格式为“du [选项] [文件]”。

### 添加交换分区 

- SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常 用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设 计目的是为了解决真实物理内存不足的问题

- 但由于交换分区毕竟是通过硬盘设备读写数据的， 速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源

  

## 磁盘容量配额

- 以使用 quota 命令进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数
- quota 命令还有软限制和硬限制的功能
  - 软限制：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。
  - 硬限制：当达到硬限制时会提示用户，且强制终止用户的操作。

### xfs_quota 命令 

- xfs_quota 命令是一个专门针对 XFS 文件系统来管理 quota 磁盘容量配额服务而设计的命令， 格式为“quota [参数] 配额 文件系统”。
  - -c 参数用于以参数的形式设置要执行的命令
  - -x 参数是专家模式，让运维人员能够对 quota 服务进行更多复杂的配置。

### edquota 命令

- edquota 命令用于编辑用户的 quota 配额限制，格式为“edquota [参数] [用户] ”。
  - -u 参数表示要针对哪个用户进行设置；
  - -g 参数表示要针对哪个用户组进行设置

## 软硬方式链接

- 硬链接（hard link）：硬链接文件与原始文件其实是同一个文件，只 是名字不同
- 软链接（也称为符号链接[symbolic link]）：仅仅包含所链接文件的路径名，因此能链 接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件 也将失效。

### ln 命令

- ln 命令用于创建链接文件，格式为“ln [选项] 目标”

  | 参数 | 作用                                                |
  | ---- | --------------------------------------------------- |
  | -s   | 创建“符号链接”（如果不带-s 参数，则默认创建硬链接） |
  | -f   | 强制创建文件或目录的链接                            |
  | -i   | 覆盖前先询问                                        |
  | -v   | 显示创建链接的过程                                  |

  

# 第 7章使用 RAID 与 LVM 磁盘阵列技术 

## RAID（独立冗余磁盘阵列） 

### RAID0

- RAID 0 技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成 一个大的卷组，并将数据依次写入到各个物理硬盘中。
- 这样一来，在最理想的状态下，硬盘 设备的读写性能会提升数倍，但是若任意一块硬盘发生故障将导致整个系统的数据都受到破 坏。
- RAID 0 技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错 误修复能力

### RAID 1 

- 是把两块以上的硬盘设备进行绑 定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备 份）。
- 当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常 使用。
- RAID 1 技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数 据，因此硬盘设备的利用率得以下降，从理论上来说，硬盘空间的真实可用率 只有 50%，由三块硬盘设备组成的 RAID 1 磁盘阵列的可用率只有 33%左右，以此类推。
- 由于需要把数据同时写入到两块以上的硬盘设备，这无疑也在一定程度上增大了系统计 算功能的负载。

### RAID 5 

- RAID5 技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。
- RAID 5 磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到 除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命 缺陷
- parity 部分存放的就是数据的奇偶校验信息，换句话说，就是 RAID 5 技术实 际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试 重建损坏的数据。
- RAID 这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性 与存储成本问题。

### RAID 10 

- RAID 10 技术是 RAID 1+RAID 0 技术的一个“组合体”。
- RAID 10 技术需要至少 4 块硬盘来组建，其中先分别两两制作成 RAID 1 磁盘阵列，以保 证数据的安全性；然后再对两个 RAID 1 磁盘阵列实施 RAID 0 技术，进一步提高硬盘设 备的读写速度。
- 这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损 坏 50%的硬盘设备而不丢失数据。
- 由于 RAID 10 技术继承了 RAID 0 的高读写速度和 RAID 1 的数据安全性，在不考虑成本的情况下 RAID 10 的性能都超过了 RAID 5，因此当前成为广泛使用的一种存储技术。

## 部署磁盘阵列 

### mdadm 命令

- mdadm 命令用于管理 Linux 系统中的软件 RAID 硬盘阵列，格式为“mdadm [模式]  [选项] [成员设备名称]”。

  | 参数 | 作用               |
  | ---- | ------------------ |
  | -a   | 检测设备名称       |
  | -n   | 指定设备数量       |
  | -l   | 指定 RAID 级别     |
  | -C   | 创建               |
  | -v   | 显示过程           |
  | -f   | 模拟设备损坏       |
  | -r   | 移除设备           |
  | -Q   | 查看摘要信息       |
  | -D   | 查看详细信息       |
  | -S   | 停止 RAID 磁盘阵列 |

  ````bash
  [root@linuxprobe ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde 
  mdadm: layout defaults to n2
  mdadm: layout defaults to n2
  mdadm: chunk size defaults to 512K
  mdadm: size set to 20954624K
  mdadm: Defaulting to version 1.2 metadata
  mdadm: array /dev/md0 started.
  # 把制作好的 RAID 磁盘阵列格式化为 ext4 格式
  [root@linuxprobe ~]# mkfs.ext4 /dev/md0
  mke2fs 1.42.9 (28-Dec-2013)
  Filesystem label=
  OS type: Linux
  Block size=4096 (log=2) 
  Fragment size=4096 (log=2)
  Stride=128 blocks, Stripe width=256 blocks
  2621440 inodes, 10477312 blocks
  523865 blocks (5.00%) reserved for the super user
  First data block=0
  Maximum filesystem blocks=2157969408
  320 block groups
  32768 blocks per group, 32768 fragments per group
  8192 inodes per group
  Superblock backups stored on blocks:
  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
  4096000, 7962624
  Allocating group tables: done
  Writing inode tables: done
  Creating journal (32768 blocks): done
  Writing superblocks and filesystem accounting information: done 
  # 创建挂载点然后把硬盘设备进行挂载操作。挂载成功后可看到可用空间为40GB。
  [root@linuxprobe ~]# mkdir /RAID
  [root@linuxprobe ~]# mount /dev/md0 /RAID 
  [root@linuxprobe ~]# df -h
  Filesystem Size Used Avail Use% Mounted on
  /dev/mapper/rhel-root 18G 3.0G 15G 17% /
  devtmpfs 905M 0 905M 0% /dev
  tmpfs 914M 84K 914M 1% /dev/shm
  tmpfs 914M 8.9M 905M 1% /run
  tmpfs 914M 0 914M 0% /sys/fs/cgroup
  /dev/sr0 3.5G 3.5G 0 100% /media/cdrom
  /dev/sda1 497M 119M 379M 24% /boot
  /dev/md0 40G 49M 38G 1% /RAID 
  # 查看/dev/md0 磁盘阵列的详细信息，并把挂载信息写入到配置文件中，使其永久生效。
  [root@linuxprobe ~]# mdadm -D /dev/md0 
  /dev/md0:
  Version : 1.2
  Creation Time : Tue May 5 07:43:26 2017
  Raid Level : raid10
  Array Size : 41909248 (39.97 GiB 42.92 GB)
  Used Dev Size : 20954624 (19.98 GiB 21.46 GB)
  Raid Devices : 4
  Total Devices : 4
  Persistence : Superblock is persistent
  Update Time : Tue May 5 07:46:59 2017
  State : clean
  Active Devices : 4
  Working Devices : 4
  Failed Devices : 0
  Spare Devices : 0
  Layout : near=2
  Chunk Size : 512K
  Name : localhost.localdomain:0 (local to host localhost.localdomain) 
  UUID : cc9a87d4:1e89e175:5383e1e8:a78ec62c
  Events : 17
  Number Major Minor RaidDevice State
  0 8 16 0 active sync /dev/sdb
  1 8 32 1 active sync /dev/sdc
  2 8 48 2 active sync /dev/sdd
  3 8 64 3 active sync /dev/sde
  [root@linuxprobe ~]# echo "/dev/md0 /RAID ext4 defaults 0 0" >> /etc/fstab 
  ````

  ## LVM（逻辑卷管理器） 
  
  - 在硬盘分好区或者部署为 RAID 磁盘阵列之后，再想修改硬盘分区大小就不 容易了。换句话说，当用户想要随着实际需求的变化调整硬盘分区的大小时，会受到硬盘 “灵活性”的限制。这时就需要用到另外一项非常普及的硬盘设备资源管理技术了—LVM （逻辑卷管理器）。
  - LVM 可以允许用户对硬盘资源进行动态调整。
  - 逻辑卷管理器是 Linux 系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建 初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。
  - 尽管对传统的硬盘分区进 行强制扩容或缩容从理论上来讲是可行的，但是却可能造成数据的丢失。
  - 而 LVM 技术是在硬 盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行 卷组合并
  - 这样一来，用户不必关心物理硬盘设备的低层架构和布局，就可以实现对硬盘分 区的动态调整。



# 第8章iptables 与 firewalld 防火墙 

## 防火墙管理工具 

- 防火墙策略可以基于流量的源目地址、端口号、协议、应 用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策 略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就可以保证仅有合法的流量在 企业内网和外部公网之间流动了。

## iptables 

### 策略与规则链

- 防火墙会从上至下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作 并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配 项，就去执行默认的策略。
- 一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行）， 一种是“堵”（即阻止）。
- 当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否 则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防 火墙也就失去了防范的作用。
- iptables 服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则 链，而规则链则依据数据包处理位置的不同进行分类，具体如下：
  - 在进行路由选择前处理数据包（PREROUTING）
  - 处理流入的数据包（INPUT）
  - 处理流出的数据包（OUTPUT）
  - 处理转发的数据包（FORWARD）
  - 在进行路由选择后处理数据包（POSTROUTING）
- 一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是 INPUT 规则链，该规则链可以增大黑客人员从外网入侵内网的难度。
- iptables 服务动作
  - ACCEPT（允许流量通过）
  - REJECT（拒绝流量通过，流量发送方会看到端口不 可达的响应）
  - LOG（记录日志信息）
  - DROP（拒绝流量通过，流量发送方会看到响应超时 的提醒）

### iptables 中基本的命令参数 

- iptables 命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配， 一旦匹配成功，iptables 就会根据策略规则所预设的动作来处理这些流量

- 防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则 放到前面，以免发生错误

  | 参数        | 作用                                            |
  | ----------- | ----------------------------------------------- |
  | -P          | 设置默认策略                                    |
  | -F          | 清空规则链                                      |
  | -L          | 查看规则链                                      |
  | -A          | 在规则链的末尾加入新规则                        |
  | -I num      | 在规则链的头部加入新规则                        |
  | -D num      | 删除某一条规则                                  |
  | -s          | 匹配来源地址 IP/MASK，加叹号“!”表示除这个 IP 外 |
  | -d          | 匹配目标地址                                    |
  | -i 网卡名称 | 匹配从这块网卡流入的数据                        |
  | -o 网卡名称 | 匹配从这块网卡流出的数据                        |
  | -p          | 匹配协议，如 TCP、UDP、ICMP                     |
  | --dport num | 匹配目标端口号                                  |
  | --sport num | 匹配来源端口号                                  |

  

## firewalld 

- 是 firewalld 预先准备了几套防火墙策略集合（策略模板），用户可 以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。

- firewalld 中常用的区域名称及测了规则

  | 区域     | 默认策略规则                                                 |
  | -------- | ------------------------------------------------------------ |
  | trusted  | 允许所有的数据包                                             |
  | home     | 拒绝流入的流量，除非与流出的流量相关；而如果流量与 ssh、mdns、ipp-client、 amba-client 与 dhcpv6-client 服务相关，则允许流量 |
  | internal | 等同于 home 区域                                             |
  | work     | 拒绝流入的流量，除非与流出的流量数相关；而如果流量与 ssh、ipp-client 与 dhcpv6-client 服务相关，则允许流量 |
  | public   | 拒绝流入的流量，除非与流出的流量相关；而如果流量与 ssh、dhcpv6-client 服务 相关，则允许流量 |
  | external | 拒绝流入的流量，除非与流出的流量相关；而如果流量与 ssh 服务相关，则允许流量 |
  | dmz      | 拒绝流入的流量，除非与流出的流量相关；而如果流量与 ssh 服务相关，则允许流量 |
  | block    | 拒绝流入的流量，除非与流出的流量相关                         |
  | drop     | 拒绝流入的流量，除非与流出的流量相关                         |

- firewalld-cmd 命令中使用的参数以及作用

  | 参数                          | 作用                                                 |
  | ----------------------------- | ---------------------------------------------------- |
  | --get-default-zone            | 查询默认的区域名称                                   |
  | --set-default-zone=<区域名称> | 设置默认的区域，使其永久生效                         |
  | --get-zones                   | 显示可用的区域                                       |
  | --get-services                | 显示预先定义的服务                                   |
  | --get-active-zones            | 显示当前正在使用的区域与网卡名称                     |
  | --add-source=                 | 将源自此 IP 或子网的流量导向指定的区域               |
  | --remove-source=              | 不再将源自此 IP 或子网的流量导向某个指定区域         |
  | --add-interface=<网卡名称>    | 将源自该网卡的所有流量都导向某个指定区域             |
  | --change-interface=<网卡名称> | 将某个网卡与区域进行关联                             |
  | --list-all                    | 显示当前区域的网卡配置参数、资源、端口以及服务等信息 |
  | --list-all-zones              | 显示所有区域的网卡配置参数、资源、端口以及服务等信息 |
  | --add-service=<服务名>        | 设置默认区域允许该服务的流量                         |
  | --add-port=<端口号/协议>      | 设置默认区域允许该端口的流量                         |
  | --remove-service=<服务名>     | 设置默认区域不再允许该服务的流量                     |
  | --remove-port=<端口号/协议>   | 设置默认区域不再允许该端口的流量                     |
  | --reload                      | 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则 |
  | --panic-on                    | 开启应急状况模式                                     |
  | --panic-off                   | 关闭应急状况模式                                     |

- 使用 firewalld 配置的防火墙策略默认 为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效

- 如果想让配 置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用 firewall-cmd 命令正 常设置防火墙策略时添加--permanent 参数，这样配置的防火墙策略就可以永久生效了，但是要重启。如果想让配置的策略立即生效，需要手动执行 firewall-cmd --reload 命令。

### 图形管理工具

- firewall-config 工具真的非常实用，很多原本复杂的长命令被 用图形化按钮替代，设置规则也简单明了，足以应对日常工作。

## 服务的访问控制列表 

- TCP Wrappers 是 RHEL 7 系统中默认启用的一款流量监控程序，它能够根据来访主机的地址 与本机的目标服务程序作出允许或拒绝的操作。
- Linux 系统中其实有两个层面的防火 墙，第一种是基于 TCP/IP 协议的流量过滤工具，而 TCP Wrappers 服务则是能允许或 禁止 Linux 系统提供服务的防火墙，从而在更高层面保护了 Linux 系统的安全运行。
- TCP Wrappers 服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文 件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。
- 控制列表 文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应 的允许策略则放行流量
- 如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若 找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。
- 在配置 TCP Wrappers 服务时需要遵循两个原则：
  - 编写拒绝策略规则时，填写的是服务名称，而非协议名称；
  - 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果

# 第 9 章 使用 ssh 服务管理远程主机

##  配置网络服务

### 配置网络参数 

- nmtui 命令来配置网络

### 创建网络会话

- RHEL 和 CentOS 系统默认使用 NetworkManager 来提供网络服务，这是一种动态管理网 络配置的守护进程，能够让网络设备保持连接状态。
- 可以使用 nmcli 命令来管理 Network Manager 服务。

### 绑定两块网卡 

- 借助于网卡绑定技术，不仅 可以提高网络传输速度，更重要的是，还可以确保在其中一块网卡出现故障时，依然可以正 常提供网络服务。
- 假设我们对两块网卡实施了绑定技术，这样在正常工作中它们会共同传输 数据，使得网络传输的速度变得更快；
- 而且即使有一块网卡突然出现了故障，另外一块网卡 便会立即自动顶替上去，保证数据传输不会中断。

## 远程控制服务 

### 配置 sshd 服务 

- SSH（Secure Shell）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理 Linux 系统的首选方式。

- sshd 服务配置文件中包含的参数以及作用

  | 参数                              | 作用                                    |
  | --------------------------------- | --------------------------------------- |
  | Port 22                           | 默认的 sshd 服务端口                    |
  | ListenAddress 0.0.0.0             | 设定 sshd 服务器监听的 IP 地址          |
  | Protocol 2                        | SSH 协议的版本号                        |
  | HostKey /etc/ssh/ssh_host_key     | SSH 协议版本为 1 时，DES 私钥存放的位置 |
  | HostKey /etc/ssh/ssh_host_rsa_key | SSH 协议版本为 2 时，RSA 私钥存放的位置 |
  | HostKey /etc/ssh/ssh_host_dsa_key | SSH 协议版本为 2 时，DSA 私钥存放的位置 |
  | PermitRootLogin yes               | 设定是否允许 root 管理员直接登录        |
  | StrictModes yes                   | 当远程用户的私钥改变时直接拒绝连接      |
  | MaxAuthTries 6                    | 最大密码尝试次数                        |
  | MaxSessions 10                    | 最大终端数                              |
  | PasswordAuthentication yes        | 是否允许密码验证                        |
  | PermitEmptyPasswords no           | 是否允许空密码登录（很不安全）          |

  

### 安全密钥验证

- 加密是对信息进行编码和解码的技术，它通过一定的算法（密钥）将原本可以直接阅读 的明文信息转换成密文形式。

- 密钥即是密文的钥匙，有私钥和公钥之分。在传输数据时，如 果担心被他人监听或截获，就可以在传输前先使用公钥对数据加密处理，然后再行传送。

- 这 样，只有掌握私钥的用户才能解密这段数据，除此之外的其他人即便截获了数据，一般也很 难将其破译为明文信息。

- 在生产环境中使用密码进行口令验证终归存在着被暴力破解或嗅探截获的 风险

- 配置密钥验证方式：

  - 第1步：在客户端主机中生成“密钥对”。

    ```bash
    [root@linuxprobe ~]# ssh-keygen 
    Generating public/private rsa key pair.
    Enter file in which to save the key (/root/.ssh/id_rsa):按回车键或设置密钥的存储路径
    Created directory '/root/.ssh'.
    Enter passphrase (empty for no passphrase): 直接按回车键或设置密钥的密码
    Enter same passphrase again: 再次按回车键或设置密钥的密码
    Your identification has been saved in /root/.ssh/id_rsa.
    Your public key has been saved in /root/.ssh/id_rsa.pub.
    The key fingerprint is:
    40:32:48:18:e4:ac:c0:c3:c1:ba:7c:6c:3a:a8:b5:22 root@linuxprobe.com
    The key's randomart image is:
    +--[ RSA 2048]----+
    |+*..o . |
    |*.o + |
    |o* . |
    |+ . . |
    |o.. S |
    |.. + |
    |. = |
    |E+ . |
    |+.o |
    +-----------------+ 
    ```

    

  - 第2步：把客户端主机中生成的公钥文件传送至远程主机

    ```bash
    [root@linuxprobe ~]# ssh-copy-id 192.168.10.10
    The authenticity of host '192.168.10.20 (192.168.10.10)' can't be established.
    ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.
    Are you sure you want to continue connecting (yes/no)? yes
    /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter
    out any that are already installed
    /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are
    prompted now it is to install the new keys
    root@192.168.10.10's password:此处输入远程服务器密码
    Number of key(s) added: 1
    Now try logging into the machine, with: "ssh '192.168.10.10'"
    and check to make sure that only the key(s) you wanted were added. 
    ```

    

  - 第3步：对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在 修改配置文件后保存并重启 sshd 服务程序。

    ```bash
    [root@linuxprobe ~]# vim /etc/ssh/sshd_config 
     ………………省略部分输出信息………………
     74
     75 # To disable tunneled clear text passwords, change to no here!
     76 #PasswordAuthentication yes
     77 #PermitEmptyPasswords no
     78 PasswordAuthentication no
     79
     ………………省略部分输出信息………………
    [root@linuxprobe ~]# systemctl restart sshd 
    ```

    

  - 第4步：在客户端尝试登录到服务器，此时无须输入密码也可成功登录。

    ```bash
    [root@linuxprobe ~]# ssh 192.168.10.10
    Last login: Mon Apr 13 19:34:13 2017 
    ```

    

### 远程传输命令

   - scp（secure copy）是一个基于 SSH 协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程 IP 地址:远程目录”。

   - scp 命令中可用的参数及作用

     | 参数 | 作用                       |
     | ---- | -------------------------- |
     | -v   | 显示详细的连接进度         |
     | -P   | 指定远程主机的 sshd 端口号 |
     | -r   | 用于传送文件夹             |
     | -6   | 使用 IPv6 协议             |

- 在使用 scp 命令把文件从本地复制到远程主机时，首先需要以绝对路径的形式写清本地 文件的存放位置。

- 如果要传送整个文件夹内的所有数据，还需要额外添加参数-r 进行递归操 作

- 还可以使用 scp 命令把远程主机上的文件下载到本地主机，其命令格式为“scp [参 数] 远程用户@远程 IP 地址:远程文件 本地目录”。

## 不间断会话服务

- 当与远程主机的会话被关闭 时，在远程主机上运行的命令也随之被中断。
- screen 是一款能够实现多窗口远程控制的开源服务程序，简单来说就是为了解决网络异 常中断或为了同时控制多个远程终端窗口而设计的程序。
- 用户还可以使用 screen 服务程序同 时在多个远程会话中自由切换，能够做到实现如下功能:
  - 会话恢复：即便网络中断，也可让会话随时恢复，确保用户不会失去对远程会话 的控制。
  - 多窗口：每个会话都是独立运行的，拥有各自独立的输入输出终端窗口，终端窗口内显示 过的信息也将被分开隔离保存，以便下次使用时依然能看到之前的操作记录。
  - 会话共享：当多个用户同时登录到远程服务器时，便可以使用会话共享功能让用户之 间的输入输出信息共享。

### 管理远程会话 

- screen 命令能做的事情非常多：
  - 用-S 参数创建会话窗口
  - 用-d 参数将指定会话进行 离线处理
  - 用-r 参数回复指定会话
  - 用-x 参数一次性恢复所有的会话
  - 用-ls 参数显示当前已 有的会话
  - 以及用-wipe 参数把目前无法使用的会话删除
  - ...

### 会话共享功能 

- screen 命令不仅可以确保用户在极端情况下也不丢失对系统的远程控制，保证了生产环 境中远程工作的不间断性，而且它还具有会话共享、分屏切割、会话锁定等实用的功能

- 会话共享功能是一件很酷的事情，当多个用户同时控制主机的时候，它可以把屏幕内容 共享出来，也就是说每个用户都可以看到相同的内容。

- 要实现会话共享功能，首先使用 ssd 服务程序将终端 A 远程连接到服务器，并创建一个 会话窗口。

  ```bash
  [root@client A ~]# ssh 192.168.10.10
  The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.
  ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.
  Are you sure you want to continue connecting (yes/no)? yes
  Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.
  root@192.168.10.10's password: 此处输入 root 管理员密码
  Last login: Wed May 4 07:56:29 2017
  [root@client A ~]# screen -S linuxprobe
  [root@client A ~]# 
  ```

  

- 然后，使用 ssh 服务程序将终端 B 远程连接到服务器，并执行获取远程会话的命令。接 下来，两台主机就能看到相同的内容了。

  ```bash
  [root@client B ~]# ssh 192.168.10.10
  The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.
  ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.
  Are you sure you want to continue connecting (yes/no)? yes
  Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.
  root@192.168.10.10's password: 此处输入 root 管理员密码
  Last login: Wed Feb 22 04:55:38 2017 from 192.168.10.10
  [root@client B ~]# screen -x
  [root@client B ~]
  ```

  

# 第 10 章使用 Apache 服务部署静态网站

## 网站服务程序

- 第1步：把光盘设备中的系统镜像挂载到/media/cdrom 目录

  ```bash
  [root@linuxprobe ~]# mkdir -p /media/cdrom
  [root@linuxprobe ~]# mount /dev/cdrom /media/cdrom
  mount: /dev/sr0 is write-protected, mounting read-only 
  ```

- 第2步：使用 Vim 文本编辑器创建 Yum 仓库的配置文件

  ```bash
  [root@linuxprobe ~]# vim /etc/yum.repos.d/rhel7.repo
  [rhel7]
  name=rhel7
  baseurl=file:///media/cdrom
  enabled=1
  gpgcheck=0 
  ```

  

- 第3步：动手安装 Apache 服务程序。注意，使用 yum 命令进行安装时，跟在命令后面的 Apache 服务的软件包名称为 httpd。如果直接执行 yum install apache 命令，则系统会报错。

  ```bash
  [root@linuxprobe ~]# yum install httpd
  Loaded plugins: langpacks, product-id, subscription-manager
  ………………省略部分输出信息………………
  Dependencies Resolved
  ===============================================================================
   Package Arch Version Repository Size
  ===============================================================================
  Installing:
   httpd x86_64 2.4.6-17.el7 rhel 1.2 M
  Installing for dependencies:
   apr x86_64 1.4.8-3.el7 rhel 103 k
   apr-util x86_64 1.5.2-6.el7 rhel 92 k
   httpd-tools x86_64 2.4.6-17.el7 rhel 77 k
   mailcap noarch 2.1.41-2.el7 rhel 31 k
  Transaction Summary
  ===============================================================================
  Install 1 Package (+4 Dependent packages)
  Total download size: 1.5 M
  Installed size: 4.3 M
  Is this ok [y/d/N]: y
  Downloading packages:
  ………………省略部分输出信息………………
  Complete!
  ```

  

- 第4步：启用 httpd 服务程序并将其加入到开机启动项中，使其能够随系统开机而运行， 从而持续为用户提供 Web 服务：

  ```bash
  [root@linuxprobe ~]# systemctl start httpd
  [root@linuxprobe ~]# systemctl enable httpd
  ln -s '/usr/lib/systemd/system/httpd.service' '/etc/systemd/system/multi-user.
  target.wants/httpd.service' 
  ```

  

## 配置服务文件参数

- Linux 系统中的配置文件

  | 配置文件的名称 | 存放位置                   |
  | -------------- | -------------------------- |
  | 服务目录       | /etc/httpd                 |
  | 主配置文件     | /etc/httpd/conf/httpd.conf |
  | 网站数据目录   | /var/www/html              |
  | 访问日志       | /var/log/httpd/access_log  |
  | 错误日志       | /var/log/httpd/error_log   |

- 在 httpd 服务程序的主配置文件中，存在三种类型的信息：注释行信息、全局配置、区域 配置.

| 参数           | 用途                        |
| -------------- | --------------------------- |
| ServerRoot     | 服务目录                    |
| ServerAdmin    | 管理员邮箱                  |
| User           | 运行服务的用户              |
| Group          | 运行服务的用户组            |
| ServerName     | 网站服务器的域名            |
| DocumentRoot   | 网站数据目录                |
| Directory      | 网站数据目录的权限          |
| Listen         | 监听的 IP 地址与端口号      |
| DirectoryIndex | 默认的索引页页面            |
| ErrorLog       | 错误日志文件                |
| CustomLog      | 访问日志文件                |
| Timeout        | 网页超时时间，默认为 300 秒 |

## SELinux 安全子系统 

- SELinux 技术的目的是为了让各个服务进程都受到约束，使其仅获取到本应获取的资源。
- 能够从多方面监控违法行为：
  - 对服务程序的功能进行限制（SELinux 域限制可 以确保服务程序做不了出格的事情）；
  - 对文件资源的访问限制（SELinux 安全上下文确保文件 资源只能被其所属的服务程序进行访问）。
- SELinux 服务有三种配置模式：
  - enforcing：强制启用安全策略模式，将拦截服务的不合法请求。
  - permissive：遇到服务越权访问时，只发出警告而不强制拦截。
  - disabled：对于越权的行为不警告也不拦截。

### semanage 命令 

- semanage 命令用于管理 SELinux 的策略，格式为“semanage [选项] [文件]”。
- SELinux 服务极大地提升了 Linux 系统的安全性，将用户权限牢牢地锁在笼子里。 semanage 命令不仅能够像传统 chcon 命令那样—设置文件、目录的策略，还可以管理网络 端口、消息接口（这些新特性将在本章后文中涵盖）。
- 常用参数
  -  -l 参数用于查询；
  - -a 参数用于添加；
  - -m 参数用于修改
  - -d 参数用于删除

## 个人用户主页功能

- 该功能可以让系统内所有的用户在自 己的家目录中管理个人的网站，而且访问起来也非常容易。
  - 第1步：在 httpd 服务程序中，默认没有开启个人用户主页功能。为此，我们需要编辑下 面的配置文件，然后在第 17 行的 UserDir disabled 参数前面加上井号（#），表示让 httpd 服务 程序开启个人用户主页功能；同时再把第 24 行的 UserDir public_html 参数前面的井号（#） 去掉（UserDir 参数表示网站数据在用户家目录中的保存目录名称，即 public_html 目录）。最 后，在修改完毕后记得保存。
  - 第2步：在用户家目录中建立用于保存网站数据的目录及首页面文件。另外，还需要把 家目录的权限修改为 755，保证其他人也有权限读取里面的内容。
  - 第3步：重新启动 httpd 服务程序，在浏览器的地址栏中输入网址，其格式为“网址/~ 用户名”（其中的波浪号是必需的，而且网址、波浪号、用户名之间没有空格），从理论上来 讲就可以看到用户的个人网站了。不出所料的是，系统显示报错页面，如图 10-9 所示。这一 定还是 SELinux 惹的祸。
  - 第4步：思考这次报错的原因是什么。httpd 服务程序在提供个人用户主页功能时，该用 户的网站数据目录本身就应该是存放到与这位用户对应的家目录中的，所以应该不需要修改 家目录的 SELinux 安全上下文。但是，前文还讲到了 Linux 域的概念。Linux 域确保服务程序 不能执行违规的操作，只能本本分分地为用户提供服务。httpd 服务中突然开启的这项个人用 户主页功能到底有没有被 SELinux 域默认允许呢？接下来使用 getsebool 命令查询并过滤出所有与 HTTP 协议相关的安全策略。其中，off 为禁止状态，on 为允许状态。
- 有时，网站的拥有者并不希望直接将网页内容显示出来，只想让通过身份验证的用户访 客看到里面的内容，这时就可以在网站中添加口令功能了。
  - 第1步：先使用 htpasswd 命令生成密码数据库。-c 参数表示第一次生成；后面再分 别添加密码数据库的存放文件，以及验证要用到的用户名称（该用户不必是系统中已有的 本地账户）。
  - 第2步：编辑个人用户主页功能的配置文件。把第 31～35 行的参数信息修改成下列内容， 其中井号（#）开头的内容为刘遄老师添加的注释信息，可将其忽略。随后保存并退出配置文 件，重启 httpd 服务程序即可生效。
  - 此后，当用户再想访问某个用户的个人网站时，就必须要输入账户和密码才能正常访问 了。另外，验证时使用的账户和密码是用 htpasswd 命令生成的专门用于网站登录的口令密码， 而不是系统中的用户密码，请不要搞错了。

## 虚拟主机功能 

- Apache 的虚拟主机功能是服务器基于用户请求的不同 IP 地址、主机域名或端口号，实 现提供多个网站同时为外部提供访问服务的技术

### 基于 IP 地址 

- 如果一台服务器有多个 IP 地址，而且每个 IP 地址与服务器上部署的每个网站一一对应， 这样当用户请求访问不同的 IP 地址时，会访问到不同网站的页面资源。
- 而且，每个网站都有 一个独立的 IP 地址，对搜索引擎优化也大有裨益。

### 基于主机域名 

- 当服务器无法为每个网站都分配一个独立 IP 地址的时候，可以尝试让 Apache 自动识别 用户请求的域名，从而根据不同的域名请求来传输不同的内容。
- 在这种情况下的配置更加简 单，只需要保证位于生产环境中的服务器上有一个可用的 IP 地址（这里以 192.168.10.10 为例） 就可以了。
- 由于当前还没有介绍如何配置 DNS 解析服务，因此需要手工定义 IP 地址与域名 之间的对应关系。
- /etc/hosts 是 Linux 系统中用于强制把某个主机域名解析到指定 IP 地址的配 置文件。
- 简单来说，只要这个文件配置正确，即使网卡参数中没有 DNS 信息也依然能够将域 名解析为某个 IP 地址。

### 基于端口号 

- 基于端口号的虚拟主机功能可以让用户通过指定的端口号来访问服务器上的网站资源。
- 在使用 Apache 配置虚拟网站主机功能时，基于端口号的配置方式是最复杂的。
- 因此我们不仅 要考虑 httpd 服务程序的配置因素，还需要考虑到 SELinux 服务对新开设端口的监控。
- 一般来 说，使用 80、443、8080 等端口号来提供网站访问服务是比较合理的，如果使用其他端口号 则会受到 SELinux 服务的限制。

## Apache 的访问控制 

- Apache 可以基于源主机名、源 IP 地址或源主机上的浏览器特征等信息对网站上的资源 进行访问控制。
- 它通过 Allow 指令允许某个主机访问服务器上的网站资源，通过 Deny 指令实 现禁止访问。
- 在允许或禁止访问网站资源时，还会用到 Order 指令，这个指令用来定义 Allow 或 Deny 指令起作用的顺序，其匹配原则是按照顺序进行匹配，若匹配成功则执行后面的默认 指令。
- 第1步：先在服务器上的网站数据目录中新建一个子目录，并在这个子目录中创建一个 包含 Successful 单词的首页文件。
- 第2步：打开 httpd 服务的配置文件，在第 129 行后面添加下述规则来限制源主机的访问。 这段规则的含义是允许使用 Firefox 浏览器的主机访问服务器上的首页文件，除此之外的所有 请求都将被拒绝
- 除了匹配源主机的浏览器特征之外，还可以通过匹配源主机的 IP 地址进行访问控制。例 如，我们只允许 IP 地址为 192.168.10.20 的主机访问网站资源，那么就可以在 httpd 服务配置 文件的第 129 行后面添加下述规则。这样在重启 httpd 服务程序后再用本机（即服务器，其 IP 地址为 192.168.10.10）来访问网站的首页面时就会提示访问被拒绝了

## 第 11 章使用 vsftpd 服务传输文件

## 文件传输协议 

- FTP 是一种在互联网中进行文件传输的协议，基于客户端/服务器模式，默认使用 20、21 号端口，其中端口 20（数据端口）用于进行数据传输，端口 21（命令端口）用于接受客户端 发出的相关 FTP 命令与参数。FTP 服务器普遍部署于内网中，具有容易搭建、方便管理的特 点。

- FTP 协议有下面两种工作 模式

  - 主动模式：FTP 服务器主动向客户端发起连接请求
  - 被动模式：FTP 服务器等待客户端发起连接请求（FTP 的默认工作模式）

- vsftpd（very secure ftp daemon，非常安全的 FTP 守护进程）是一款运行在 Linux 操作系 统上的 FTP 服务程序，不仅完全开源而且免费，此外，还具有很高的安全性、传输速度，以 及支持虚拟用户验证等其他 FTP 服务程序不具备的特点。

  - 在配置妥当 Yum 软件仓库之后，就可以安装 vsftpd 服务程序了。

    ```bash
    [root@linuxprobe ~]# yum install vsftpd
    Loaded plugins: langpacks, product-id, subscription-manager
    ………………省略部分输出信息………………
    ===============================================================================
    Package Arch Version Repository Size
    ===============================================================================
    Installing:
    vsftpd x86_64 3.0.2-9.el7 rhel 166 k
    Transaction Summary
    ===============================================================================
    Install 1 Package
    Total download size: 166 k
    Installed size: 343 k
    Is this ok [y/d/N]: y
    Downloading packages:
    Running transaction check
    Running transaction test
    Transaction test succeeded
    Running transaction
    Installing : vsftpd-3.0.2-9.el7.x86_64 1/1
    Verifying : vsftpd-3.0.2-9.el7.x86_64 1/1
    Installed:
    vsftpd.x86_64 0:3.0.2-9.el7
    Complete! 
    ```

  - iptables 防火墙管理工具默认禁止了 FTP 传输协议的端口号，因此在正式配置 vsftpd 服务 程序之前，为了避免这些默认的防火墙策略“捣乱”，还需要清空 iptables 防火墙的默认策略， 并把当前已经被清理的防火墙策略状态保存下来：

    ```bash
    [root@linuxprobe ~]# iptables -F
    [root@linuxprobe ~]# service iptables save
    iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ] 
    ```

  - vsftpd 服务程序常用的参数以及作用

    | 参数                                                   | 作用                                                         |
    | ------------------------------------------------------ | ------------------------------------------------------------ |
    | listen=[YES \| NO]                                     | 是否以独立运行的方式监听服务                                 |
    | listen_address=IP 地址                                 | 设置要监听的 IP 地址                                         |
    | listen_port=21                                         | 设置 FTP 服务的监听端口                                      |
    | download_enable＝[YES \| NO]                           | 是否允许下载文件                                             |
    | userlist_enable=[YES \| NO ] userlist_deny=[YES\| NO ] | 设置用户列表为“允许”还是“禁止”操作                           |
    | max_clients=0                                          | 最大客户端连接数，0 为不限制                                 |
    | max_per_ip=0                                           | 同一 IP 地址的最大连接数，0 为不限制                         |
    | anonymous_enable=[YES \| NO ]                          | 是否允许匿名用户访问                                         |
    | anon_upload_enable=[YES \| NO ]                        | 是否允许匿名用户上传文件                                     |
    | anon_umask=022                                         | 匿名用户上传文件的 umask 值                                  |
    | anon_root=/var/ftp                                     | 匿名用户的 FTP 根目录                                        |
    | anon_mkdir_write_enable=[YES \| NO ]                   | 是否允许匿名用户创建目录                                     |
    | anon_other_write_enable=[YES \| NO ]                   | 是否开放匿名用户的其他写入权限（包括重命名、删 除等操作权限） |
    | anon_max_rate=0                                        | 匿名用户的最大传输速率（字节/秒），0 为不限制                |
    | local_enable=[YES \| NO]                               | 是否允许本地用户登录 FTP                                     |
    | local_umask=022                                        | 本地用户上传文件的 umask 值                                  |
    | local_root=/var/ftp                                    | 本地用户的 FTP 根目录                                        |
    | chroot_local_user=[YES \| NO ]                         | 是否将用户权限禁锢在 FTP 目录，以确保安全                    |
    | local_max_rate=0                                       | 本地用户最大传输速率（字节/秒），0 为不限制                  |

    

## vsftpd 服务程序 

- vsftpd 作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到 FTP 服务 器上。
- 匿名开放模式：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录 到 FTP 服务器。
- 本地用户模式：是通过 Linux 系统本地的账户密码信息进行认证的模式，相较于匿名 开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可 以畅通无阻地登录 FTP 服务器，从而完全控制整台服务器
- 虚拟用户模式：是这三种模式中最安全的一种认证模式，它需要为 FTP 服务单独 建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在 服务器系统中实际上是不存在的，仅供 FTP 服务程序进行认证使用。这样，即使 黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。



### 匿名开放模式 

- vsftpd 服务程序默认开启了匿名开放模式，我们需要做的就是开放匿名用户的上传、下载文件的权限，以及让匿名用户创建、删除、更名文件的权限。

- 可以向匿名用户开放的权限参数以及作用

  | 参数                        | 作用                               |
  | --------------------------- | ---------------------------------- |
  | anonymous_enable=YES        | 允许匿名访问模式                   |
  | anon_umask=022              | 匿名用户上传文件的 umask 值        |
  | anon_upload_enable=YES      | 允许匿名用户上传文件               |
  | anon_mkdir_write_enable=YES | 允许匿名用户创建目录               |
  | anon_other_write_enable=YES | 允许匿名用户修改目录名称或删除目录 |

  

### 本地用户模式

- 相较于匿名开放模式，本地用户模式要更安全，而且配置起来也很简单。

- 本地用户模式使用的权限参数以及作用

  | 参数                | 作用                                                 |
  | ------------------- | ---------------------------------------------------- |
  | anonymous_enable=NO | 禁止匿名访问模式                                     |
  | local_enable=YES    | 允许本地用户模式                                     |
  | write_enable=YES    | 设置可写权限                                         |
  | local_umask=022     | 本地用户模式创建文件的 umask 值                      |
  | userlist_enable=YES | 启用“禁止用户名单”，名单文件为 ftpusers 和 user_list |
  | userlist_deny=YES   | 开启用户作用名单文件功能                             |



### 虚拟用户模式 

- 以配置流程

  - 第1步：创建用于进行 FTP 认证的用户数据库文件，其中奇数行为账户名，偶数行为密 码。

  - 第2步：创建 vsftpd 服务程序用于存储文件的根目录以及虚拟用户映射的系统本地 用户。

  - 第3步：建立用于支持虚拟用户的 PAM 文件。

  - 第4步：在 vsftpd 服务程序的主配置文件中通过 pam_service_name 参数将 PAM 认证 文件的名称修改为 vsftpd.vu，PAM 作为应用程序层与鉴别模块层的连接纽带，可以让应用程 序根据需求灵活地在自身插入所需的鉴别功能模块。当应用程序需要 PAM 认证时，则需要在 应用程序中定义负责认证的 PAM 配置文件，实现所需的认证功能。

  - 利用 PAM 文件进行认证时使用的参数以及作用

    | 参数                       | 作用                                                         |
    | -------------------------- | ------------------------------------------------------------ |
    | anonymous_enable=NO        | 禁止匿名开放模式                                             |
    | local_enable=YES           | 允许本地用户模式                                             |
    | guest_enable=YES           | 开启虚拟用户模式                                             |
    | guest_username=virtual     | 指定虚拟用户账户                                             |
    | pam_service_name=vsftpd.vu | 指定 PAM 文件                                                |
    | allow_writeable_chroot=YES | 允许对禁锢的FTP 根目录执行写入操作，而且不拒绝用户的登录请求 |

    

  - 第5步：为虚拟用户设置不同的权限。虽然账户 zhangsan 和 lisi 都是用于 vsftpd 服务程 序认证的虚拟账户，但是我们依然想对这两人进行区别对待。比如，允许张三上传、创建、 修改、查看、删除文件，只允许李四查看文件。

  - 第6步：设置 SELinux 域允许策略，然后使用虚拟用户模式登录 FTP 服务器。相信大家 可以猜到，SELinux 会继续来捣乱。所以，先按照前面实验中的步骤开启 SELinux 域的允许 策略，以免再次出现操作失败的情况

  

## 简单文件传输协议 

- 简单文件传输协议（Trivial File Transfer Protocol，TFTP）是一种基于 UDP 协议在客户端 和服务器之间进行简单文件传输的协议。顾名思义，它提供不复杂、开销不大的文件传输服 务（可将其当作 FTP 协议的简化版本）。

- TFTP 的命令功能不如 FTP 服务强大，甚至不能遍历目录，在安全性方面也弱于 FTP 服务。

- 由于 TFTP 在传输文件时采用的是 UDP 协议，占用的端口号为 69，因此 文件的传输过程也不像 FTP 协议那样可靠

- 但是，因为 TFTP 不需要客户端的权限认证， 也就减少了无谓的系统和网络带宽消耗，因此在传输琐碎（trivial）不大的文件时，效率 更高。

- tftp 命令中可用的参数以及作用

  | 命令    | 作用                  |
  | ------- | --------------------- |
  | ?       | 帮助信息              |
  | put     | 上传文件              |
  | get     | 下载文件              |
  | verbose | 显示详细的处理信息    |
  | status  | 显示当前的状态信息    |
  | binary  | 使用二进制进行传输    |
  | ascii   | 使用 ASCII 码进行传输 |
  | timeout | 设置重传的超时时间    |
  | quit    | 退出                  |

  

# 第12章使用 Samba 或 NFS 实现文件共享 

## Samba 文件共享服务

- Samba 服务程序现在已经成为在 Linux 系统与 Windows 系统之间共享文件的最佳选择。

- Samba 服务程序中的参数以及作用

  | [global]   | 参数                                                         | 作用                                                   |
  | ---------- | ------------------------------------------------------------ | ------------------------------------------------------ |
  |            | workgroup = MYGROUP                                          | \#工作组名称                                           |
  |            | server string = Samba Server Version %v                      | \#服务器介绍信息，参数%v 为显示 SMB 版本号             |
  |            | log file = /var/log/samba/log.%m                             | \#定义日志文件的存放位置与名称，参数%m 为 来访的主机名 |
  |            | max log size = 50                                            | \#定义日志文件的最大容量为 50KB                        |
  |            | security = user                                              | \#安全验证的方式，总共有 4 种                          |
  |            | \#share：来访主机无需验证口令；比较方便，但安全性很差        |                                                        |
  |            | \#user：需验证来访主机提供的口令后才可以访问；提升了安全性   |                                                        |
  |            | \#server：使用独立的远程主机验证来访主机提供的口令（集中管理账户） |                                                        |
  |            | \#domain：使用域控制器进行身份验证                           |                                                        |
  |            | passdb backend = tdbsam                                      | \#定义用户后台的类型，共有 3 种                        |
  |            | \#smbpasswd：使用 smbpasswd 命令为系统用户设置 Samba 服务程序的密码 |                                                        |
  |            | \#tdbsam：创建数据库文件并使用 pdbedit 命令建立 Samba 服务程序的用户 |                                                        |
  |            | \#ldapsam：基于 LDAP 服务进行账户验证                        |                                                        |
  |            | load printers = yes                                          | \#设置在 Samba 服务启动时是否共享打印机设备            |
  |            | cups options = raw                                           | \#打印机的选项                                         |
  | [homes]    |                                                              | \#共享参数                                             |
  |            | comment = Home Directories                                   | \#描述信息                                             |
  |            | browseable = no                                              | \#指定共享信息是否在“网上邻居”中可见                   |
  |            | writable = yes                                               | \#定义是否可以执行写入操作，与“read only” 相反         |
  | [printers] |                                                              | \#打印机共享参数                                       |



### 配置共享资源 

- 用于设置 Samba 服务程序的参数以及作用

  | 参数                                                  | 作用                       |
  | ----------------------------------------------------- | -------------------------- |
  | [database]                                            | 共享名称为 database        |
  | comment = Do not arbitrarily modify the database file | 警告用户不要随意修改数据库 |
  | path = /home/database                                 | 共享目录为/home/database   |
  | public = no                                           | 关闭“所有人可见”           |
  | writable = yes                                        | 允许写入操作               |

- 第1步：创建用于访问共享资源的账户信息。

  - pdbedit 命令用于管理 SMB 服务程序的账户信息数据库，格式为“pdbedit [选项] 账户”。

  - 用于 pdbedit 命令的参数以及作用

    | 参数      | 作用                   |
    | --------- | ---------------------- |
    | -a 用户名 | 建立 Samba 账户        |
    | -x 用户名 | 删除 Samba 账户        |
    | -L        | 列出账户列表           |
    | -Lv       | 列出账户详细信息的列表 |

- 第2步：创建用于共享资源的文件目录。

- 第3步：设置 SELinux 服务与策略，使其允许通过 Samba 服务程序访问普通用户家目录。

- 第4步：在 Samba 服务程序的主配置文件中，根据表式写入共享信息。

- 第5步：Samba 服务程序的配置工作基本完毕。

### Windows 访问文件共享服务 

### Linux 访问文件共享服务 

## NFS（网络文件系统） 

- NFS（网络文件系统）服 务可以将远程 Linux 系统上的文件共享资源挂载到本地主机的目录上，从而使得本地主机 （Linux 客户端）基于 TCP/IP 协议，像使用本地主机上的资源那样读写远程 Linux 系统上的共 享文件。
- 第1步：为了检验 NFS 服务配置的效果，我们需要使用两台 Linux 主机（一台充当 NFS 服务器，一台充当 NFS 客户端），并按照表 12-6 来设置它们所使用的 IP 地址。
- 第2步：在 NFS 服务器上建立用于 NFS 文件共享的目录，并设置足够的权限确保其他 人也有写入权限。
- 第3步：NFS 服务程序的配置文件为/etc/exports，默认情况下里面没有任何内容。我们 可以按照“共享目录的路径 允许访问的 NFS 客户端（共享权限参数）”的格式，定义要共享 的目录与相应的权限。
- 第4步：启动和启用 NFS 服务程序。由于在使用 NFS 服务进行文件共享之前，需要使 用 RPC（Remote Procedure Call，远程过程调用）服务将 NFS 服务器的 IP 地址和端口号等信 息发送给客户端。因此，在启动 NFS 服务之前，还需要顺带重启并启用 rpcbind 服务程序， 并将这两个服务一并加入开机启动项中。

## autofs 自动挂载服务 

- 与 mount 命令不同，autofs 服务程序是一 种 Linux 系统守护进程，当检测到用户视图访问一个尚未挂载的文件系统时，将自动挂载该 文件系统
- 我们将挂载信息填入/etc/fstab 文件后，系统在每次开机时都自动将其挂载， 而 autofs 服务程序则是在用户需要使用该文件系统时才去动态挂载，从而节约了网络资源和 服务器的硬件资源。

